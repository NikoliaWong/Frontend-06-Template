学习笔记

# 字典树
    1. 字典树是一种树形结构，树形由root根节点和子节点组成
    2. 根节点是没有值的
    3. 从根节点的子节点开始，每个子节点存储一个字符，每个字符都不相同
    4. 从根节点到某节点，所形成的路径，将该路径中的所有节点的值连接起来，就是这个节点所对应的字符串
    5. 字典树可以用来搜索和统计，效率比hash高，是用空间换时间
    6. 查询和遍历都是从当前节点的子节点开始

# KMP算法和BM算法
    KMP是前缀匹配和BM后缀匹配的经典算法，看得出来前缀匹配和后缀匹配的区别就仅仅在于比较的顺序不同。
    前缀匹配是指：模式串和母串的比较从左到右，模式串的移动也是从 左到右
    后缀匹配是指：模式串和母串的的比较从右到左，模式串的移动从左到右。

    KMP也是一种优化版的前缀算法，之所以叫KMP就是Knuth、Morris、Pratt三个人名的缩写，
    对比下BF那么KMP的算法的优化点就在“每次往后移动的距离”它会动态的调整每次模式串的移动距离，BF是每次都+1，KMP则不一定。

    移动位数 = 已匹配的字符数 - 对应的部分匹配值

# 字符串分析算法
    字典树：大量高重复字符串的存储与分析（检查两个字符串是否完全匹配）。
    KMP：在长字符串里找模式（两个字符串，一个字符串是另一个字符串的部分）。
    Wildcard：带通配符的字符串模式。（问号表示匹配任意字符，星号表示匹配任意数量的任意字符）。一般用于文件查找。
    正则：字符串通用模式匹配。
    状态机：通用的字符串分析。
    LL LR：字符串多层级结构分析。

# Object.create(null) 
    new Object() 通过构造函数来创建对象, 添加的属性是在自身实例下。
    Object.create() es6创建对象的另一种方式，可以理解为继承一个对象, 添加的属性是在原型下。
    这样创建字符串可以避免收到Object.prototype原型上的污染

# =+ +=
    表达式 A=+B 会进行 B转化为数字 赋值给A
    表达式 A+=B 会进行 A = A + B; 也就是js的加法运算

# for of / for in
    for of：遍历数组里的每一项。（无法循环遍历对象）
    for in：循环遍历的是数组的键值(索引)，而for of循环遍历的是数组的值。
            for in 会遍历自定义属性，for of不会

